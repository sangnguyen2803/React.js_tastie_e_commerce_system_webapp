{"ast":null,"code":"import { lerp } from './math-utils';\nimport { scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\nvar EPSILON = 0.01;\nvar VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nexport default function flyToViewport(startProps, endProps, t) {\n  var viewport = {};\n  var rho = 1.414;\n  var startZoom = startProps.zoom;\n  var startCenter = [startProps.longitude, startProps.latitude];\n  var startScale = zoomToScale(startZoom);\n  var endZoom = endProps.zoom;\n  var endCenter = [endProps.longitude, endProps.latitude];\n  var scale = zoomToScale(endZoom - startZoom);\n  var startCenterXY = lngLatToWorld(startCenter, startScale);\n  var endCenterXY = lngLatToWorld(endCenter, startScale);\n  var uDelta = vec2.sub([], endCenterXY, startCenterXY);\n  var w0 = Math.max(startProps.width, startProps.height);\n  var w1 = w0 / scale;\n  var u1 = vec2.length(uDelta);\n\n  if (Math.abs(u1) < EPSILON) {\n    for (var _i = 0; _i < VIEWPORT_TRANSITION_PROPS.length; _i++) {\n      var key = VIEWPORT_TRANSITION_PROPS[_i];\n      var startValue = startProps[key];\n      var endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n\n    return viewport;\n  }\n\n  var rho2 = rho * rho;\n  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);\n  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);\n  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  var S = (r1 - r0) / rho;\n  var s = t * S;\n  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n  var scaleIncrement = 1 / w;\n  var newZoom = startZoom + scaleToZoom(scaleIncrement);\n  var newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  vec2.scale(newCenterWorld, newCenterWorld, scaleIncrement);\n  var newCenter = worldToLngLat(newCenterWorld, zoomToScale(newZoom));\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}","map":{"version":3,"sources":["../../src/fly-to-viewport.js"],"names":["EPSILON","VIEWPORT_TRANSITION_PROPS","viewport","rho","startZoom","startProps","startCenter","startScale","zoomToScale","endZoom","endProps","endCenter","scale","startCenterXY","lngLatToWorld","endCenterXY","uDelta","vec2","w0","Math","w1","u1","key","startValue","endValue","lerp","rho2","b0","b1","r0","r1","S","s","t","w","u","scaleIncrement","newZoom","scaleToZoom","newCenterWorld","newCenter","worldToLngLat"],"mappings":"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","sourcesContent":["import {lerp} from './math-utils';\nimport {\n  scaleToZoom,\n  zoomToScale,\n  lngLatToWorld,\n  worldToLngLat\n} from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n*/\n/* eslint-disable max-statements */\nexport default function flyToViewport(startProps, endProps, t) {\n  // Equations from above paper are referred where needed.\n\n  const viewport = {};\n\n  // TODO: add this as an option for applications.\n  const rho = 1.414;\n\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = lngLatToWorld(startCenter, startScale);\n  const endCenterXY = lngLatToWorld(endCenter, startScale);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta);\n  // u0 is treated as '0' in Eq (9).\n\n  // If change in center is too small, do linear interpolaiton.\n  if (Math.abs(u1) < EPSILON) {\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    return viewport;\n  }\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  const s = t * S;\n\n  const w = (Math.cosh(r0) / Math.cosh(r0 + rho * s));\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n  vec2.scale(newCenterWorld, newCenterWorld, scaleIncrement);\n\n  const newCenter = worldToLngLat(\n    newCenterWorld,\n    zoomToScale(newZoom));\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\n/* eslint-enable max-statements */\n"]},"metadata":{},"sourceType":"module"}